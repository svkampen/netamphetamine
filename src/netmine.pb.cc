// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: netmine.proto

#include "netmine.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_netmine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ChunkBytes_netmine_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_netmine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ChunkRequest_netmine_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_netmine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ClearAt_netmine_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_netmine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_CursorMove_netmine_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_netmine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Player_netmine_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_netmine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SquareFlag_netmine_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_netmine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SquareOpen_netmine_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_netmine_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Welcome_netmine_2eproto;
namespace nm {
namespace message {
class MessageWrapperDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MessageWrapper> _instance;
} _MessageWrapper_default_instance_;
class ClearAtDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ClearAt> _instance;
} _ClearAt_default_instance_;
class ChunkRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ChunkRequest> _instance;
} _ChunkRequest_default_instance_;
class ChunkBytesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ChunkBytes> _instance;
} _ChunkBytes_default_instance_;
class CursorMoveDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CursorMove> _instance;
} _CursorMove_default_instance_;
class SquareOpenDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SquareOpen> _instance;
} _SquareOpen_default_instance_;
class SquareFlagDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SquareFlag> _instance;
} _SquareFlag_default_instance_;
class PlayerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Player> _instance;
} _Player_default_instance_;
class WelcomeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Welcome> _instance;
} _Welcome_default_instance_;
}  // namespace message
}  // namespace nm
static void InitDefaultsMessageWrapper_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_MessageWrapper_default_instance_;
    new (ptr) ::nm::message::MessageWrapper();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::MessageWrapper::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<8> scc_info_MessageWrapper_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 8, InitDefaultsMessageWrapper_netmine_2eproto}, {
      &scc_info_CursorMove_netmine_2eproto.base,
      &scc_info_SquareOpen_netmine_2eproto.base,
      &scc_info_ChunkBytes_netmine_2eproto.base,
      &scc_info_SquareFlag_netmine_2eproto.base,
      &scc_info_Player_netmine_2eproto.base,
      &scc_info_Welcome_netmine_2eproto.base,
      &scc_info_ChunkRequest_netmine_2eproto.base,
      &scc_info_ClearAt_netmine_2eproto.base,}};

static void InitDefaultsClearAt_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_ClearAt_default_instance_;
    new (ptr) ::nm::message::ClearAt();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::ClearAt::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ClearAt_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsClearAt_netmine_2eproto}, {}};

static void InitDefaultsChunkRequest_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_ChunkRequest_default_instance_;
    new (ptr) ::nm::message::ChunkRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::ChunkRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ChunkRequest_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsChunkRequest_netmine_2eproto}, {}};

static void InitDefaultsChunkBytes_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_ChunkBytes_default_instance_;
    new (ptr) ::nm::message::ChunkBytes();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::ChunkBytes::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ChunkBytes_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsChunkBytes_netmine_2eproto}, {}};

static void InitDefaultsCursorMove_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_CursorMove_default_instance_;
    new (ptr) ::nm::message::CursorMove();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::CursorMove::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CursorMove_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCursorMove_netmine_2eproto}, {}};

static void InitDefaultsSquareOpen_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_SquareOpen_default_instance_;
    new (ptr) ::nm::message::SquareOpen();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::SquareOpen::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SquareOpen_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSquareOpen_netmine_2eproto}, {}};

static void InitDefaultsSquareFlag_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_SquareFlag_default_instance_;
    new (ptr) ::nm::message::SquareFlag();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::SquareFlag::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SquareFlag_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSquareFlag_netmine_2eproto}, {}};

static void InitDefaultsPlayer_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_Player_default_instance_;
    new (ptr) ::nm::message::Player();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::Player::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Player_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPlayer_netmine_2eproto}, {}};

static void InitDefaultsWelcome_netmine_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nm::message::_Welcome_default_instance_;
    new (ptr) ::nm::message::Welcome();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::nm::message::Welcome::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Welcome_netmine_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsWelcome_netmine_2eproto}, {
      &scc_info_Player_netmine_2eproto.base,}};

void InitDefaults_netmine_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_MessageWrapper_netmine_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ClearAt_netmine_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ChunkRequest_netmine_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ChunkBytes_netmine_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CursorMove_netmine_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SquareOpen_netmine_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SquareFlag_netmine_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Player_netmine_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Welcome_netmine_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_netmine_2eproto[9];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_netmine_2eproto[1];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_netmine_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_netmine_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, type_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, cursormove_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, squareopen_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, chunkbytes_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, squareflag_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, playerjoin_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, playerquit_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, welcome_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, chunkrequest_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, clearat_),
  PROTOBUF_FIELD_OFFSET(::nm::message::MessageWrapper, player_),
  10,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::nm::message::ClearAt, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::ClearAt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::ClearAt, x_),
  PROTOBUF_FIELD_OFFSET(::nm::message::ClearAt, y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkRequest, x_),
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkRequest, y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkBytes, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkBytes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkBytes, x_),
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkBytes, y_),
  PROTOBUF_FIELD_OFFSET(::nm::message::ChunkBytes, data_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::nm::message::CursorMove, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::CursorMove, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::CursorMove, x_),
  PROTOBUF_FIELD_OFFSET(::nm::message::CursorMove, y_),
  PROTOBUF_FIELD_OFFSET(::nm::message::CursorMove, id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareOpen, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareOpen, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareOpen, x_),
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareOpen, y_),
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareOpen, id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareFlag, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareFlag, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareFlag, x_),
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareFlag, y_),
  PROTOBUF_FIELD_OFFSET(::nm::message::SquareFlag, id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::nm::message::Player, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::Player, x_),
  PROTOBUF_FIELD_OFFSET(::nm::message::Player, y_),
  PROTOBUF_FIELD_OFFSET(::nm::message::Player, id_),
  PROTOBUF_FIELD_OFFSET(::nm::message::Player, name_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::nm::message::Welcome, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nm::message::Welcome, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nm::message::Welcome, version_),
  PROTOBUF_FIELD_OFFSET(::nm::message::Welcome, nplayers_),
  PROTOBUF_FIELD_OFFSET(::nm::message::Welcome, players_),
  0,
  1,
  ~0u,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 16, sizeof(::nm::message::MessageWrapper)},
  { 27, 34, sizeof(::nm::message::ClearAt)},
  { 36, 43, sizeof(::nm::message::ChunkRequest)},
  { 45, 53, sizeof(::nm::message::ChunkBytes)},
  { 56, 64, sizeof(::nm::message::CursorMove)},
  { 67, 75, sizeof(::nm::message::SquareOpen)},
  { 78, 86, sizeof(::nm::message::SquareFlag)},
  { 89, 98, sizeof(::nm::message::Player)},
  { 102, 110, sizeof(::nm::message::Welcome)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_MessageWrapper_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_ClearAt_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_ChunkRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_ChunkBytes_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_CursorMove_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_SquareOpen_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_SquareFlag_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_Player_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::nm::message::_Welcome_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_netmine_2eproto = {
  {}, AddDescriptors_netmine_2eproto, "netmine.proto", schemas,
  file_default_instances, TableStruct_netmine_2eproto::offsets,
  file_level_metadata_netmine_2eproto, 9, file_level_enum_descriptors_netmine_2eproto, file_level_service_descriptors_netmine_2eproto,
};

const char descriptor_table_protodef_netmine_2eproto[] =
  "\n\rnetmine.proto\022\nnm.message\"\217\005\n\016MessageW"
  "rapper\022-\n\004type\030\001 \002(\0162\037.nm.message.Messag"
  "eWrapper.Type\022*\n\ncursorMove\030\002 \001(\0132\026.nm.m"
  "essage.CursorMove\022*\n\nsquareOpen\030\003 \001(\0132\026."
  "nm.message.SquareOpen\022*\n\nchunkBytes\030\004 \001("
  "\0132\026.nm.message.ChunkBytes\022*\n\nsquareFlag\030"
  "\005 \001(\0132\026.nm.message.SquareFlag\022&\n\nplayerJ"
  "oin\030\006 \001(\0132\022.nm.message.Player\022&\n\nplayerQ"
  "uit\030\007 \001(\0132\022.nm.message.Player\022$\n\007welcome"
  "\030\010 \001(\0132\023.nm.message.Welcome\022.\n\014chunkRequ"
  "est\030\t \001(\0132\030.nm.message.ChunkRequest\022$\n\007c"
  "learAt\030\n \001(\0132\023.nm.message.ClearAt\022\"\n\006pla"
  "yer\030\013 \001(\0132\022.nm.message.Player\"\255\001\n\004Type\022\017"
  "\n\013CURSOR_MOVE\020\001\022\017\n\013SQUARE_FLAG\020\002\022\017\n\013SQUA"
  "RE_OPEN\020\003\022\017\n\013PLAYER_JOIN\020\004\022\017\n\013PLAYER_QUI"
  "T\020\005\022\013\n\007WELCOME\020\006\022\017\n\013CHUNK_BYTES\020\007\022\021\n\rCHU"
  "NK_REQUEST\020\010\022\014\n\010CLEAR_AT\020\t\022\021\n\rPLAYER_UPD"
  "ATE\020\n\"\037\n\007ClearAt\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\"$"
  "\n\014ChunkRequest\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\"0\n\n"
  "ChunkBytes\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\022\014\n\004data"
  "\030\003 \002(\014\".\n\nCursorMove\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002"
  "(\005\022\n\n\002id\030\003 \001(\005\".\n\nSquareOpen\022\t\n\001x\030\001 \002(\005\022"
  "\t\n\001y\030\002 \002(\005\022\n\n\002id\030\003 \001(\005\".\n\nSquareFlag\022\t\n\001"
  "x\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\022\n\n\002id\030\003 \001(\005\"8\n\006Player"
  "\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\022\n\n\002id\030\003 \001(\005\022\014\n\004na"
  "me\030\004 \001(\t\"Q\n\007Welcome\022\017\n\007version\030\001 \002(\005\022\020\n\010"
  "nPlayers\030\002 \002(\005\022#\n\007players\030\003 \003(\0132\022.nm.mes"
  "sage.Player"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_netmine_2eproto = {
  false, InitDefaults_netmine_2eproto, 
  descriptor_table_protodef_netmine_2eproto,
  "netmine.proto", &assign_descriptors_table_netmine_2eproto, 1091,
};

void AddDescriptors_netmine_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_netmine_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_netmine_2eproto = []() { AddDescriptors_netmine_2eproto(); return true; }();
namespace nm {
namespace message {
const ::google::protobuf::EnumDescriptor* MessageWrapper_Type_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_netmine_2eproto);
  return file_level_enum_descriptors_netmine_2eproto[0];
}
bool MessageWrapper_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const MessageWrapper_Type MessageWrapper::CURSOR_MOVE;
const MessageWrapper_Type MessageWrapper::SQUARE_FLAG;
const MessageWrapper_Type MessageWrapper::SQUARE_OPEN;
const MessageWrapper_Type MessageWrapper::PLAYER_JOIN;
const MessageWrapper_Type MessageWrapper::PLAYER_QUIT;
const MessageWrapper_Type MessageWrapper::WELCOME;
const MessageWrapper_Type MessageWrapper::CHUNK_BYTES;
const MessageWrapper_Type MessageWrapper::CHUNK_REQUEST;
const MessageWrapper_Type MessageWrapper::CLEAR_AT;
const MessageWrapper_Type MessageWrapper::PLAYER_UPDATE;
const MessageWrapper_Type MessageWrapper::Type_MIN;
const MessageWrapper_Type MessageWrapper::Type_MAX;
const int MessageWrapper::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void MessageWrapper::InitAsDefaultInstance() {
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->cursormove_ = const_cast< ::nm::message::CursorMove*>(
      ::nm::message::CursorMove::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->squareopen_ = const_cast< ::nm::message::SquareOpen*>(
      ::nm::message::SquareOpen::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->chunkbytes_ = const_cast< ::nm::message::ChunkBytes*>(
      ::nm::message::ChunkBytes::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->squareflag_ = const_cast< ::nm::message::SquareFlag*>(
      ::nm::message::SquareFlag::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->playerjoin_ = const_cast< ::nm::message::Player*>(
      ::nm::message::Player::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->playerquit_ = const_cast< ::nm::message::Player*>(
      ::nm::message::Player::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->welcome_ = const_cast< ::nm::message::Welcome*>(
      ::nm::message::Welcome::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->chunkrequest_ = const_cast< ::nm::message::ChunkRequest*>(
      ::nm::message::ChunkRequest::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->clearat_ = const_cast< ::nm::message::ClearAt*>(
      ::nm::message::ClearAt::internal_default_instance());
  ::nm::message::_MessageWrapper_default_instance_._instance.get_mutable()->player_ = const_cast< ::nm::message::Player*>(
      ::nm::message::Player::internal_default_instance());
}
class MessageWrapper::HasBitSetters {
 public:
  static void set_has_type(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static const ::nm::message::CursorMove& cursormove(const MessageWrapper* msg);
  static void set_has_cursormove(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::nm::message::SquareOpen& squareopen(const MessageWrapper* msg);
  static void set_has_squareopen(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::nm::message::ChunkBytes& chunkbytes(const MessageWrapper* msg);
  static void set_has_chunkbytes(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::nm::message::SquareFlag& squareflag(const MessageWrapper* msg);
  static void set_has_squareflag(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::nm::message::Player& playerjoin(const MessageWrapper* msg);
  static void set_has_playerjoin(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::nm::message::Player& playerquit(const MessageWrapper* msg);
  static void set_has_playerquit(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static const ::nm::message::Welcome& welcome(const MessageWrapper* msg);
  static void set_has_welcome(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static const ::nm::message::ChunkRequest& chunkrequest(const MessageWrapper* msg);
  static void set_has_chunkrequest(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static const ::nm::message::ClearAt& clearat(const MessageWrapper* msg);
  static void set_has_clearat(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static const ::nm::message::Player& player(const MessageWrapper* msg);
  static void set_has_player(MessageWrapper* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
};

const ::nm::message::CursorMove&
MessageWrapper::HasBitSetters::cursormove(const MessageWrapper* msg) {
  return *msg->cursormove_;
}
const ::nm::message::SquareOpen&
MessageWrapper::HasBitSetters::squareopen(const MessageWrapper* msg) {
  return *msg->squareopen_;
}
const ::nm::message::ChunkBytes&
MessageWrapper::HasBitSetters::chunkbytes(const MessageWrapper* msg) {
  return *msg->chunkbytes_;
}
const ::nm::message::SquareFlag&
MessageWrapper::HasBitSetters::squareflag(const MessageWrapper* msg) {
  return *msg->squareflag_;
}
const ::nm::message::Player&
MessageWrapper::HasBitSetters::playerjoin(const MessageWrapper* msg) {
  return *msg->playerjoin_;
}
const ::nm::message::Player&
MessageWrapper::HasBitSetters::playerquit(const MessageWrapper* msg) {
  return *msg->playerquit_;
}
const ::nm::message::Welcome&
MessageWrapper::HasBitSetters::welcome(const MessageWrapper* msg) {
  return *msg->welcome_;
}
const ::nm::message::ChunkRequest&
MessageWrapper::HasBitSetters::chunkrequest(const MessageWrapper* msg) {
  return *msg->chunkrequest_;
}
const ::nm::message::ClearAt&
MessageWrapper::HasBitSetters::clearat(const MessageWrapper* msg) {
  return *msg->clearat_;
}
const ::nm::message::Player&
MessageWrapper::HasBitSetters::player(const MessageWrapper* msg) {
  return *msg->player_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MessageWrapper::kTypeFieldNumber;
const int MessageWrapper::kCursorMoveFieldNumber;
const int MessageWrapper::kSquareOpenFieldNumber;
const int MessageWrapper::kChunkBytesFieldNumber;
const int MessageWrapper::kSquareFlagFieldNumber;
const int MessageWrapper::kPlayerJoinFieldNumber;
const int MessageWrapper::kPlayerQuitFieldNumber;
const int MessageWrapper::kWelcomeFieldNumber;
const int MessageWrapper::kChunkRequestFieldNumber;
const int MessageWrapper::kClearAtFieldNumber;
const int MessageWrapper::kPlayerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MessageWrapper::MessageWrapper()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.MessageWrapper)
}
MessageWrapper::MessageWrapper(const MessageWrapper& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_cursormove()) {
    cursormove_ = new ::nm::message::CursorMove(*from.cursormove_);
  } else {
    cursormove_ = nullptr;
  }
  if (from.has_squareopen()) {
    squareopen_ = new ::nm::message::SquareOpen(*from.squareopen_);
  } else {
    squareopen_ = nullptr;
  }
  if (from.has_chunkbytes()) {
    chunkbytes_ = new ::nm::message::ChunkBytes(*from.chunkbytes_);
  } else {
    chunkbytes_ = nullptr;
  }
  if (from.has_squareflag()) {
    squareflag_ = new ::nm::message::SquareFlag(*from.squareflag_);
  } else {
    squareflag_ = nullptr;
  }
  if (from.has_playerjoin()) {
    playerjoin_ = new ::nm::message::Player(*from.playerjoin_);
  } else {
    playerjoin_ = nullptr;
  }
  if (from.has_playerquit()) {
    playerquit_ = new ::nm::message::Player(*from.playerquit_);
  } else {
    playerquit_ = nullptr;
  }
  if (from.has_welcome()) {
    welcome_ = new ::nm::message::Welcome(*from.welcome_);
  } else {
    welcome_ = nullptr;
  }
  if (from.has_chunkrequest()) {
    chunkrequest_ = new ::nm::message::ChunkRequest(*from.chunkrequest_);
  } else {
    chunkrequest_ = nullptr;
  }
  if (from.has_clearat()) {
    clearat_ = new ::nm::message::ClearAt(*from.clearat_);
  } else {
    clearat_ = nullptr;
  }
  if (from.has_player()) {
    player_ = new ::nm::message::Player(*from.player_);
  } else {
    player_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:nm.message.MessageWrapper)
}

void MessageWrapper::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_MessageWrapper_netmine_2eproto.base);
  ::memset(&cursormove_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&player_) -
      reinterpret_cast<char*>(&cursormove_)) + sizeof(player_));
  type_ = 1;
}

MessageWrapper::~MessageWrapper() {
  // @@protoc_insertion_point(destructor:nm.message.MessageWrapper)
  SharedDtor();
}

void MessageWrapper::SharedDtor() {
  if (this != internal_default_instance()) delete cursormove_;
  if (this != internal_default_instance()) delete squareopen_;
  if (this != internal_default_instance()) delete chunkbytes_;
  if (this != internal_default_instance()) delete squareflag_;
  if (this != internal_default_instance()) delete playerjoin_;
  if (this != internal_default_instance()) delete playerquit_;
  if (this != internal_default_instance()) delete welcome_;
  if (this != internal_default_instance()) delete chunkrequest_;
  if (this != internal_default_instance()) delete clearat_;
  if (this != internal_default_instance()) delete player_;
}

void MessageWrapper::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MessageWrapper& MessageWrapper::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_MessageWrapper_netmine_2eproto.base);
  return *internal_default_instance();
}


void MessageWrapper::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.MessageWrapper)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(cursormove_ != nullptr);
      cursormove_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(squareopen_ != nullptr);
      squareopen_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(chunkbytes_ != nullptr);
      chunkbytes_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(squareflag_ != nullptr);
      squareflag_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(playerjoin_ != nullptr);
      playerjoin_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(playerquit_ != nullptr);
      playerquit_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(welcome_ != nullptr);
      welcome_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(chunkrequest_ != nullptr);
      chunkrequest_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(clearat_ != nullptr);
      clearat_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(player_ != nullptr);
      player_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MessageWrapper::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MessageWrapper*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .nm.message.MessageWrapper.Type type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::nm::message::MessageWrapper_Type_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_type(static_cast<::nm::message::MessageWrapper_Type>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .nm.message.CursorMove cursorMove = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::CursorMove::_InternalParse;
        object = msg->mutable_cursormove();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.SquareOpen squareOpen = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::SquareOpen::_InternalParse;
        object = msg->mutable_squareopen();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.ChunkBytes chunkBytes = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::ChunkBytes::_InternalParse;
        object = msg->mutable_chunkbytes();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.SquareFlag squareFlag = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::SquareFlag::_InternalParse;
        object = msg->mutable_squareflag();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.Player playerJoin = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::Player::_InternalParse;
        object = msg->mutable_playerjoin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.Player playerQuit = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::Player::_InternalParse;
        object = msg->mutable_playerquit();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.Welcome welcome = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::Welcome::_InternalParse;
        object = msg->mutable_welcome();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.ChunkRequest chunkRequest = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::ChunkRequest::_InternalParse;
        object = msg->mutable_chunkrequest();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.ClearAt clearAt = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::ClearAt::_InternalParse;
        object = msg->mutable_clearat();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .nm.message.Player player = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::nm::message::Player::_InternalParse;
        object = msg->mutable_player();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MessageWrapper::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.MessageWrapper)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .nm.message.MessageWrapper.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::nm::message::MessageWrapper_Type_IsValid(value)) {
            set_type(static_cast< ::nm::message::MessageWrapper_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.CursorMove cursorMove = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_cursormove()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.SquareOpen squareOpen = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_squareopen()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.ChunkBytes chunkBytes = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_chunkbytes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.SquareFlag squareFlag = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_squareflag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.Player playerJoin = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_playerjoin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.Player playerQuit = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_playerquit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.Welcome welcome = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_welcome()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.ChunkRequest chunkRequest = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_chunkrequest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.ClearAt clearAt = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (82 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_clearat()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .nm.message.Player player = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_player()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.MessageWrapper)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.MessageWrapper)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MessageWrapper::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.MessageWrapper)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .nm.message.MessageWrapper.Type type = 1;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .nm.message.CursorMove cursorMove = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::cursormove(this), output);
  }

  // optional .nm.message.SquareOpen squareOpen = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::squareopen(this), output);
  }

  // optional .nm.message.ChunkBytes chunkBytes = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::chunkbytes(this), output);
  }

  // optional .nm.message.SquareFlag squareFlag = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::squareflag(this), output);
  }

  // optional .nm.message.Player playerJoin = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, HasBitSetters::playerjoin(this), output);
  }

  // optional .nm.message.Player playerQuit = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, HasBitSetters::playerquit(this), output);
  }

  // optional .nm.message.Welcome welcome = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, HasBitSetters::welcome(this), output);
  }

  // optional .nm.message.ChunkRequest chunkRequest = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, HasBitSetters::chunkrequest(this), output);
  }

  // optional .nm.message.ClearAt clearAt = 10;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, HasBitSetters::clearat(this), output);
  }

  // optional .nm.message.Player player = 11;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, HasBitSetters::player(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.MessageWrapper)
}

::google::protobuf::uint8* MessageWrapper::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.MessageWrapper)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .nm.message.MessageWrapper.Type type = 1;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .nm.message.CursorMove cursorMove = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::cursormove(this), target);
  }

  // optional .nm.message.SquareOpen squareOpen = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::squareopen(this), target);
  }

  // optional .nm.message.ChunkBytes chunkBytes = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::chunkbytes(this), target);
  }

  // optional .nm.message.SquareFlag squareFlag = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::squareflag(this), target);
  }

  // optional .nm.message.Player playerJoin = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, HasBitSetters::playerjoin(this), target);
  }

  // optional .nm.message.Player playerQuit = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, HasBitSetters::playerquit(this), target);
  }

  // optional .nm.message.Welcome welcome = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, HasBitSetters::welcome(this), target);
  }

  // optional .nm.message.ChunkRequest chunkRequest = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, HasBitSetters::chunkrequest(this), target);
  }

  // optional .nm.message.ClearAt clearAt = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, HasBitSetters::clearat(this), target);
  }

  // optional .nm.message.Player player = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, HasBitSetters::player(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.MessageWrapper)
  return target;
}

size_t MessageWrapper::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.MessageWrapper)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .nm.message.MessageWrapper.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .nm.message.CursorMove cursorMove = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *cursormove_);
    }

    // optional .nm.message.SquareOpen squareOpen = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *squareopen_);
    }

    // optional .nm.message.ChunkBytes chunkBytes = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *chunkbytes_);
    }

    // optional .nm.message.SquareFlag squareFlag = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *squareflag_);
    }

    // optional .nm.message.Player playerJoin = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *playerjoin_);
    }

    // optional .nm.message.Player playerQuit = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *playerquit_);
    }

    // optional .nm.message.Welcome welcome = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *welcome_);
    }

    // optional .nm.message.ChunkRequest chunkRequest = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *chunkrequest_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .nm.message.ClearAt clearAt = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *clearat_);
    }

    // optional .nm.message.Player player = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *player_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageWrapper::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.MessageWrapper)
  GOOGLE_DCHECK_NE(&from, this);
  const MessageWrapper* source =
      ::google::protobuf::DynamicCastToGenerated<MessageWrapper>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.MessageWrapper)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.MessageWrapper)
    MergeFrom(*source);
  }
}

void MessageWrapper::MergeFrom(const MessageWrapper& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.MessageWrapper)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_cursormove()->::nm::message::CursorMove::MergeFrom(from.cursormove());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_squareopen()->::nm::message::SquareOpen::MergeFrom(from.squareopen());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_chunkbytes()->::nm::message::ChunkBytes::MergeFrom(from.chunkbytes());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_squareflag()->::nm::message::SquareFlag::MergeFrom(from.squareflag());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_playerjoin()->::nm::message::Player::MergeFrom(from.playerjoin());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_playerquit()->::nm::message::Player::MergeFrom(from.playerquit());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_welcome()->::nm::message::Welcome::MergeFrom(from.welcome());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_chunkrequest()->::nm::message::ChunkRequest::MergeFrom(from.chunkrequest());
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      mutable_clearat()->::nm::message::ClearAt::MergeFrom(from.clearat());
    }
    if (cached_has_bits & 0x00000200u) {
      mutable_player()->::nm::message::Player::MergeFrom(from.player());
    }
    if (cached_has_bits & 0x00000400u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MessageWrapper::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.MessageWrapper)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageWrapper::CopyFrom(const MessageWrapper& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.MessageWrapper)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageWrapper::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000400) != 0x00000400) return false;
  if (has_cursormove()) {
    if (!this->cursormove_->IsInitialized()) return false;
  }
  if (has_squareopen()) {
    if (!this->squareopen_->IsInitialized()) return false;
  }
  if (has_chunkbytes()) {
    if (!this->chunkbytes_->IsInitialized()) return false;
  }
  if (has_squareflag()) {
    if (!this->squareflag_->IsInitialized()) return false;
  }
  if (has_playerjoin()) {
    if (!this->playerjoin_->IsInitialized()) return false;
  }
  if (has_playerquit()) {
    if (!this->playerquit_->IsInitialized()) return false;
  }
  if (has_welcome()) {
    if (!this->welcome_->IsInitialized()) return false;
  }
  if (has_chunkrequest()) {
    if (!this->chunkrequest_->IsInitialized()) return false;
  }
  if (has_clearat()) {
    if (!this->clearat_->IsInitialized()) return false;
  }
  if (has_player()) {
    if (!this->player_->IsInitialized()) return false;
  }
  return true;
}

void MessageWrapper::Swap(MessageWrapper* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MessageWrapper::InternalSwap(MessageWrapper* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(cursormove_, other->cursormove_);
  swap(squareopen_, other->squareopen_);
  swap(chunkbytes_, other->chunkbytes_);
  swap(squareflag_, other->squareflag_);
  swap(playerjoin_, other->playerjoin_);
  swap(playerquit_, other->playerquit_);
  swap(welcome_, other->welcome_);
  swap(chunkrequest_, other->chunkrequest_);
  swap(clearat_, other->clearat_);
  swap(player_, other->player_);
  swap(type_, other->type_);
}

::google::protobuf::Metadata MessageWrapper::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ClearAt::InitAsDefaultInstance() {
}
class ClearAt::HasBitSetters {
 public:
  static void set_has_x(ClearAt* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(ClearAt* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClearAt::kXFieldNumber;
const int ClearAt::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClearAt::ClearAt()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.ClearAt)
}
ClearAt::ClearAt(const ClearAt& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:nm.message.ClearAt)
}

void ClearAt::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

ClearAt::~ClearAt() {
  // @@protoc_insertion_point(destructor:nm.message.ClearAt)
  SharedDtor();
}

void ClearAt::SharedDtor() {
}

void ClearAt::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClearAt& ClearAt::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ClearAt_netmine_2eproto.base);
  return *internal_default_instance();
}


void ClearAt::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.ClearAt)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ClearAt::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ClearAt*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ClearAt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.ClearAt)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.ClearAt)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.ClearAt)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ClearAt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.ClearAt)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.ClearAt)
}

::google::protobuf::uint8* ClearAt::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.ClearAt)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.ClearAt)
  return target;
}

size_t ClearAt::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:nm.message.ClearAt)
  size_t total_size = 0;

  if (has_x()) {
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  return total_size;
}
size_t ClearAt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.ClearAt)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClearAt::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.ClearAt)
  GOOGLE_DCHECK_NE(&from, this);
  const ClearAt* source =
      ::google::protobuf::DynamicCastToGenerated<ClearAt>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.ClearAt)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.ClearAt)
    MergeFrom(*source);
  }
}

void ClearAt::MergeFrom(const ClearAt& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.ClearAt)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ClearAt::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.ClearAt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClearAt::CopyFrom(const ClearAt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.ClearAt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearAt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void ClearAt::Swap(ClearAt* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClearAt::InternalSwap(ClearAt* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
}

::google::protobuf::Metadata ClearAt::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ChunkRequest::InitAsDefaultInstance() {
}
class ChunkRequest::HasBitSetters {
 public:
  static void set_has_x(ChunkRequest* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(ChunkRequest* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChunkRequest::kXFieldNumber;
const int ChunkRequest::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChunkRequest::ChunkRequest()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.ChunkRequest)
}
ChunkRequest::ChunkRequest(const ChunkRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:nm.message.ChunkRequest)
}

void ChunkRequest::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

ChunkRequest::~ChunkRequest() {
  // @@protoc_insertion_point(destructor:nm.message.ChunkRequest)
  SharedDtor();
}

void ChunkRequest::SharedDtor() {
}

void ChunkRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ChunkRequest& ChunkRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ChunkRequest_netmine_2eproto.base);
  return *internal_default_instance();
}


void ChunkRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.ChunkRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ChunkRequest::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ChunkRequest*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ChunkRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.ChunkRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.ChunkRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.ChunkRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ChunkRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.ChunkRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.ChunkRequest)
}

::google::protobuf::uint8* ChunkRequest::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.ChunkRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.ChunkRequest)
  return target;
}

size_t ChunkRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:nm.message.ChunkRequest)
  size_t total_size = 0;

  if (has_x()) {
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  return total_size;
}
size_t ChunkRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.ChunkRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChunkRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.ChunkRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const ChunkRequest* source =
      ::google::protobuf::DynamicCastToGenerated<ChunkRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.ChunkRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.ChunkRequest)
    MergeFrom(*source);
  }
}

void ChunkRequest::MergeFrom(const ChunkRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.ChunkRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ChunkRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.ChunkRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChunkRequest::CopyFrom(const ChunkRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.ChunkRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void ChunkRequest::Swap(ChunkRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChunkRequest::InternalSwap(ChunkRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
}

::google::protobuf::Metadata ChunkRequest::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ChunkBytes::InitAsDefaultInstance() {
}
class ChunkBytes::HasBitSetters {
 public:
  static void set_has_x(ChunkBytes* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_y(ChunkBytes* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_data(ChunkBytes* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChunkBytes::kXFieldNumber;
const int ChunkBytes::kYFieldNumber;
const int ChunkBytes::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChunkBytes::ChunkBytes()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.ChunkBytes)
}
ChunkBytes::ChunkBytes(const ChunkBytes& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data()) {
    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:nm.message.ChunkBytes)
}

void ChunkBytes::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ChunkBytes_netmine_2eproto.base);
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

ChunkBytes::~ChunkBytes() {
  // @@protoc_insertion_point(destructor:nm.message.ChunkBytes)
  SharedDtor();
}

void ChunkBytes::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ChunkBytes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ChunkBytes& ChunkBytes::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ChunkBytes_netmine_2eproto.base);
  return *internal_default_instance();
}


void ChunkBytes::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.ChunkBytes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ChunkBytes::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ChunkBytes*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required bytes data = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_data();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ChunkBytes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.ChunkBytes)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.ChunkBytes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.ChunkBytes)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ChunkBytes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.ChunkBytes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // required bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.ChunkBytes)
}

::google::protobuf::uint8* ChunkBytes::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.ChunkBytes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  // required bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.ChunkBytes)
  return target;
}

size_t ChunkBytes::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:nm.message.ChunkBytes)
  size_t total_size = 0;

  if (has_data()) {
    // required bytes data = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }

  if (has_x()) {
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  return total_size;
}
size_t ChunkBytes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.ChunkBytes)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes data = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());

    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChunkBytes::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.ChunkBytes)
  GOOGLE_DCHECK_NE(&from, this);
  const ChunkBytes* source =
      ::google::protobuf::DynamicCastToGenerated<ChunkBytes>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.ChunkBytes)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.ChunkBytes)
    MergeFrom(*source);
  }
}

void ChunkBytes::MergeFrom(const ChunkBytes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.ChunkBytes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ChunkBytes::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.ChunkBytes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChunkBytes::CopyFrom(const ChunkBytes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.ChunkBytes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkBytes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void ChunkBytes::Swap(ChunkBytes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChunkBytes::InternalSwap(ChunkBytes* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(x_, other->x_);
  swap(y_, other->y_);
}

::google::protobuf::Metadata ChunkBytes::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CursorMove::InitAsDefaultInstance() {
}
class CursorMove::HasBitSetters {
 public:
  static void set_has_x(CursorMove* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(CursorMove* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_id(CursorMove* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CursorMove::kXFieldNumber;
const int CursorMove::kYFieldNumber;
const int CursorMove::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CursorMove::CursorMove()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.CursorMove)
}
CursorMove::CursorMove(const CursorMove& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&x_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:nm.message.CursorMove)
}

void CursorMove::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&x_)) + sizeof(id_));
}

CursorMove::~CursorMove() {
  // @@protoc_insertion_point(destructor:nm.message.CursorMove)
  SharedDtor();
}

void CursorMove::SharedDtor() {
}

void CursorMove::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CursorMove& CursorMove::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CursorMove_netmine_2eproto.base);
  return *internal_default_instance();
}


void CursorMove::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.CursorMove)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&id_) -
        reinterpret_cast<char*>(&x_)) + sizeof(id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CursorMove::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CursorMove*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 id = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CursorMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.CursorMove)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.CursorMove)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.CursorMove)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CursorMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.CursorMove)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.CursorMove)
}

::google::protobuf::uint8* CursorMove::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.CursorMove)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.CursorMove)
  return target;
}

size_t CursorMove::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:nm.message.CursorMove)
  size_t total_size = 0;

  if (has_x()) {
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  return total_size;
}
size_t CursorMove::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.CursorMove)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 id = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CursorMove::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.CursorMove)
  GOOGLE_DCHECK_NE(&from, this);
  const CursorMove* source =
      ::google::protobuf::DynamicCastToGenerated<CursorMove>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.CursorMove)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.CursorMove)
    MergeFrom(*source);
  }
}

void CursorMove::MergeFrom(const CursorMove& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.CursorMove)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CursorMove::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.CursorMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CursorMove::CopyFrom(const CursorMove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.CursorMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CursorMove::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void CursorMove::Swap(CursorMove* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CursorMove::InternalSwap(CursorMove* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata CursorMove::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SquareOpen::InitAsDefaultInstance() {
}
class SquareOpen::HasBitSetters {
 public:
  static void set_has_x(SquareOpen* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(SquareOpen* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_id(SquareOpen* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SquareOpen::kXFieldNumber;
const int SquareOpen::kYFieldNumber;
const int SquareOpen::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SquareOpen::SquareOpen()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.SquareOpen)
}
SquareOpen::SquareOpen(const SquareOpen& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&x_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:nm.message.SquareOpen)
}

void SquareOpen::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&x_)) + sizeof(id_));
}

SquareOpen::~SquareOpen() {
  // @@protoc_insertion_point(destructor:nm.message.SquareOpen)
  SharedDtor();
}

void SquareOpen::SharedDtor() {
}

void SquareOpen::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SquareOpen& SquareOpen::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SquareOpen_netmine_2eproto.base);
  return *internal_default_instance();
}


void SquareOpen::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.SquareOpen)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&id_) -
        reinterpret_cast<char*>(&x_)) + sizeof(id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SquareOpen::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SquareOpen*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 id = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SquareOpen::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.SquareOpen)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.SquareOpen)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.SquareOpen)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SquareOpen::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.SquareOpen)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.SquareOpen)
}

::google::protobuf::uint8* SquareOpen::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.SquareOpen)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.SquareOpen)
  return target;
}

size_t SquareOpen::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:nm.message.SquareOpen)
  size_t total_size = 0;

  if (has_x()) {
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  return total_size;
}
size_t SquareOpen::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.SquareOpen)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 id = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SquareOpen::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.SquareOpen)
  GOOGLE_DCHECK_NE(&from, this);
  const SquareOpen* source =
      ::google::protobuf::DynamicCastToGenerated<SquareOpen>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.SquareOpen)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.SquareOpen)
    MergeFrom(*source);
  }
}

void SquareOpen::MergeFrom(const SquareOpen& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.SquareOpen)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SquareOpen::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.SquareOpen)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SquareOpen::CopyFrom(const SquareOpen& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.SquareOpen)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SquareOpen::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void SquareOpen::Swap(SquareOpen* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SquareOpen::InternalSwap(SquareOpen* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata SquareOpen::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SquareFlag::InitAsDefaultInstance() {
}
class SquareFlag::HasBitSetters {
 public:
  static void set_has_x(SquareFlag* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(SquareFlag* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_id(SquareFlag* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SquareFlag::kXFieldNumber;
const int SquareFlag::kYFieldNumber;
const int SquareFlag::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SquareFlag::SquareFlag()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.SquareFlag)
}
SquareFlag::SquareFlag(const SquareFlag& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&x_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:nm.message.SquareFlag)
}

void SquareFlag::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&x_)) + sizeof(id_));
}

SquareFlag::~SquareFlag() {
  // @@protoc_insertion_point(destructor:nm.message.SquareFlag)
  SharedDtor();
}

void SquareFlag::SharedDtor() {
}

void SquareFlag::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SquareFlag& SquareFlag::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SquareFlag_netmine_2eproto.base);
  return *internal_default_instance();
}


void SquareFlag::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.SquareFlag)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&id_) -
        reinterpret_cast<char*>(&x_)) + sizeof(id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SquareFlag::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SquareFlag*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 id = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SquareFlag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.SquareFlag)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.SquareFlag)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.SquareFlag)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SquareFlag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.SquareFlag)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.SquareFlag)
}

::google::protobuf::uint8* SquareFlag::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.SquareFlag)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.SquareFlag)
  return target;
}

size_t SquareFlag::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:nm.message.SquareFlag)
  size_t total_size = 0;

  if (has_x()) {
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  return total_size;
}
size_t SquareFlag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.SquareFlag)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 id = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SquareFlag::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.SquareFlag)
  GOOGLE_DCHECK_NE(&from, this);
  const SquareFlag* source =
      ::google::protobuf::DynamicCastToGenerated<SquareFlag>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.SquareFlag)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.SquareFlag)
    MergeFrom(*source);
  }
}

void SquareFlag::MergeFrom(const SquareFlag& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.SquareFlag)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SquareFlag::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.SquareFlag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SquareFlag::CopyFrom(const SquareFlag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.SquareFlag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SquareFlag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void SquareFlag::Swap(SquareFlag* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SquareFlag::InternalSwap(SquareFlag* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata SquareFlag::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Player::InitAsDefaultInstance() {
}
class Player::HasBitSetters {
 public:
  static void set_has_x(Player* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_y(Player* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_id(Player* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_name(Player* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Player::kXFieldNumber;
const int Player::kYFieldNumber;
const int Player::kIdFieldNumber;
const int Player::kNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Player::Player()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.Player)
}
Player::Player(const Player& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&x_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:nm.message.Player)
}

void Player::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Player_netmine_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&x_)) + sizeof(id_));
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:nm.message.Player)
  SharedDtor();
}

void Player::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Player::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Player& Player::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Player_netmine_2eproto.base);
  return *internal_default_instance();
}


void Player::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.Player)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&id_) -
        reinterpret_cast<char*>(&x_)) + sizeof(id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Player::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Player*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 id = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string name = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("nm.message.Player.name");
        object = msg->mutable_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Player::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.Player)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "nm.message.Player.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.Player)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.Player)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Player::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.Player)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->id(), output);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "nm.message.Player.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.Player)
}

::google::protobuf::uint8* Player::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.Player)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->id(), target);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "nm.message.Player.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.Player)
  return target;
}

size_t Player::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:nm.message.Player)
  size_t total_size = 0;

  if (has_x()) {
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  return total_size;
}
size_t Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.Player)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string name = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // optional int32 id = 3;
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Player::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.Player)
  GOOGLE_DCHECK_NE(&from, this);
  const Player* source =
      ::google::protobuf::DynamicCastToGenerated<Player>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.Player)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.Player)
    MergeFrom(*source);
  }
}

void Player::MergeFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.Player)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000008u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Player::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Player::CopyFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  return true;
}

void Player::Swap(Player* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Player::InternalSwap(Player* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata Player::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Welcome::InitAsDefaultInstance() {
}
class Welcome::HasBitSetters {
 public:
  static void set_has_version(Welcome* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_nplayers(Welcome* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Welcome::kVersionFieldNumber;
const int Welcome::kNPlayersFieldNumber;
const int Welcome::kPlayersFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Welcome::Welcome()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nm.message.Welcome)
}
Welcome::Welcome(const Welcome& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      players_(from.players_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&nplayers_) -
    reinterpret_cast<char*>(&version_)) + sizeof(nplayers_));
  // @@protoc_insertion_point(copy_constructor:nm.message.Welcome)
}

void Welcome::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Welcome_netmine_2eproto.base);
  ::memset(&version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nplayers_) -
      reinterpret_cast<char*>(&version_)) + sizeof(nplayers_));
}

Welcome::~Welcome() {
  // @@protoc_insertion_point(destructor:nm.message.Welcome)
  SharedDtor();
}

void Welcome::SharedDtor() {
}

void Welcome::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Welcome& Welcome::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Welcome_netmine_2eproto.base);
  return *internal_default_instance();
}


void Welcome::Clear() {
// @@protoc_insertion_point(message_clear_start:nm.message.Welcome)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  players_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nplayers_) -
        reinterpret_cast<char*>(&version_)) + sizeof(nplayers_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Welcome::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Welcome*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 version = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 nPlayers = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_nplayers(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .nm.message.Player players = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::nm::message::Player::_InternalParse;
          object = msg->add_players();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 26 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Welcome::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nm.message.Welcome)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 nPlayers = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_nplayers(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nplayers_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .nm.message.Player players = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_players()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nm.message.Welcome)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nm.message.Welcome)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Welcome::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nm.message.Welcome)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }

  // required int32 nPlayers = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nplayers(), output);
  }

  // repeated .nm.message.Player players = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->players_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->players(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nm.message.Welcome)
}

::google::protobuf::uint8* Welcome::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nm.message.Welcome)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->version(), target);
  }

  // required int32 nPlayers = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nplayers(), target);
  }

  // repeated .nm.message.Player players = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->players_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->players(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nm.message.Welcome)
  return target;
}

size_t Welcome::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:nm.message.Welcome)
  size_t total_size = 0;

  if (has_version()) {
    // required int32 version = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->version());
  }

  if (has_nplayers()) {
    // required int32 nPlayers = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->nplayers());
  }

  return total_size;
}
size_t Welcome::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nm.message.Welcome)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 version = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->version());

    // required int32 nPlayers = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->nplayers());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .nm.message.Player players = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->players_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->players(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Welcome::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nm.message.Welcome)
  GOOGLE_DCHECK_NE(&from, this);
  const Welcome* source =
      ::google::protobuf::DynamicCastToGenerated<Welcome>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nm.message.Welcome)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nm.message.Welcome)
    MergeFrom(*source);
  }
}

void Welcome::MergeFrom(const Welcome& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nm.message.Welcome)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  players_.MergeFrom(from.players_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000002u) {
      nplayers_ = from.nplayers_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Welcome::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nm.message.Welcome)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Welcome::CopyFrom(const Welcome& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nm.message.Welcome)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Welcome::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->players())) return false;
  return true;
}

void Welcome::Swap(Welcome* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Welcome::InternalSwap(Welcome* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&players_)->InternalSwap(CastToBase(&other->players_));
  swap(version_, other->version_);
  swap(nplayers_, other->nplayers_);
}

::google::protobuf::Metadata Welcome::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_netmine_2eproto);
  return ::file_level_metadata_netmine_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace message
}  // namespace nm
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::nm::message::MessageWrapper* Arena::CreateMaybeMessage< ::nm::message::MessageWrapper >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::MessageWrapper >(arena);
}
template<> PROTOBUF_NOINLINE ::nm::message::ClearAt* Arena::CreateMaybeMessage< ::nm::message::ClearAt >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::ClearAt >(arena);
}
template<> PROTOBUF_NOINLINE ::nm::message::ChunkRequest* Arena::CreateMaybeMessage< ::nm::message::ChunkRequest >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::ChunkRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::nm::message::ChunkBytes* Arena::CreateMaybeMessage< ::nm::message::ChunkBytes >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::ChunkBytes >(arena);
}
template<> PROTOBUF_NOINLINE ::nm::message::CursorMove* Arena::CreateMaybeMessage< ::nm::message::CursorMove >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::CursorMove >(arena);
}
template<> PROTOBUF_NOINLINE ::nm::message::SquareOpen* Arena::CreateMaybeMessage< ::nm::message::SquareOpen >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::SquareOpen >(arena);
}
template<> PROTOBUF_NOINLINE ::nm::message::SquareFlag* Arena::CreateMaybeMessage< ::nm::message::SquareFlag >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::SquareFlag >(arena);
}
template<> PROTOBUF_NOINLINE ::nm::message::Player* Arena::CreateMaybeMessage< ::nm::message::Player >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::Player >(arena);
}
template<> PROTOBUF_NOINLINE ::nm::message::Welcome* Arena::CreateMaybeMessage< ::nm::message::Welcome >(Arena* arena) {
  return Arena::CreateInternal< ::nm::message::Welcome >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
