// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: netmine.proto

#ifndef PROTOBUF_INCLUDED_netmine_2eproto
#define PROTOBUF_INCLUDED_netmine_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_netmine_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_netmine_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_netmine_2eproto();
namespace nm {
namespace message {
class ChunkBytes;
class ChunkBytesDefaultTypeInternal;
extern ChunkBytesDefaultTypeInternal _ChunkBytes_default_instance_;
class ChunkRequest;
class ChunkRequestDefaultTypeInternal;
extern ChunkRequestDefaultTypeInternal _ChunkRequest_default_instance_;
class ClearAt;
class ClearAtDefaultTypeInternal;
extern ClearAtDefaultTypeInternal _ClearAt_default_instance_;
class CursorMove;
class CursorMoveDefaultTypeInternal;
extern CursorMoveDefaultTypeInternal _CursorMove_default_instance_;
class MessageWrapper;
class MessageWrapperDefaultTypeInternal;
extern MessageWrapperDefaultTypeInternal _MessageWrapper_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class SquareFlag;
class SquareFlagDefaultTypeInternal;
extern SquareFlagDefaultTypeInternal _SquareFlag_default_instance_;
class SquareOpen;
class SquareOpenDefaultTypeInternal;
extern SquareOpenDefaultTypeInternal _SquareOpen_default_instance_;
class Welcome;
class WelcomeDefaultTypeInternal;
extern WelcomeDefaultTypeInternal _Welcome_default_instance_;
}  // namespace message
}  // namespace nm
namespace google {
namespace protobuf {
template<> ::nm::message::ChunkBytes* Arena::CreateMaybeMessage<::nm::message::ChunkBytes>(Arena*);
template<> ::nm::message::ChunkRequest* Arena::CreateMaybeMessage<::nm::message::ChunkRequest>(Arena*);
template<> ::nm::message::ClearAt* Arena::CreateMaybeMessage<::nm::message::ClearAt>(Arena*);
template<> ::nm::message::CursorMove* Arena::CreateMaybeMessage<::nm::message::CursorMove>(Arena*);
template<> ::nm::message::MessageWrapper* Arena::CreateMaybeMessage<::nm::message::MessageWrapper>(Arena*);
template<> ::nm::message::Player* Arena::CreateMaybeMessage<::nm::message::Player>(Arena*);
template<> ::nm::message::SquareFlag* Arena::CreateMaybeMessage<::nm::message::SquareFlag>(Arena*);
template<> ::nm::message::SquareOpen* Arena::CreateMaybeMessage<::nm::message::SquareOpen>(Arena*);
template<> ::nm::message::Welcome* Arena::CreateMaybeMessage<::nm::message::Welcome>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nm {
namespace message {

enum MessageWrapper_Type {
  MessageWrapper_Type_CURSOR_MOVE = 1,
  MessageWrapper_Type_SQUARE_FLAG = 2,
  MessageWrapper_Type_SQUARE_OPEN = 3,
  MessageWrapper_Type_PLAYER_JOIN = 4,
  MessageWrapper_Type_PLAYER_QUIT = 5,
  MessageWrapper_Type_WELCOME = 6,
  MessageWrapper_Type_CHUNK_BYTES = 7,
  MessageWrapper_Type_CHUNK_REQUEST = 8,
  MessageWrapper_Type_CLEAR_AT = 9,
  MessageWrapper_Type_PLAYER_UPDATE = 10
};
bool MessageWrapper_Type_IsValid(int value);
const MessageWrapper_Type MessageWrapper_Type_Type_MIN = MessageWrapper_Type_CURSOR_MOVE;
const MessageWrapper_Type MessageWrapper_Type_Type_MAX = MessageWrapper_Type_PLAYER_UPDATE;
const int MessageWrapper_Type_Type_ARRAYSIZE = MessageWrapper_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageWrapper_Type_descriptor();
inline const ::std::string& MessageWrapper_Type_Name(MessageWrapper_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageWrapper_Type_descriptor(), value);
}
inline bool MessageWrapper_Type_Parse(
    const ::std::string& name, MessageWrapper_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageWrapper_Type>(
    MessageWrapper_Type_descriptor(), name, value);
}
// ===================================================================

class MessageWrapper final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.MessageWrapper) */ {
 public:
  MessageWrapper();
  virtual ~MessageWrapper();

  MessageWrapper(const MessageWrapper& from);

  inline MessageWrapper& operator=(const MessageWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageWrapper(MessageWrapper&& from) noexcept
    : MessageWrapper() {
    *this = ::std::move(from);
  }

  inline MessageWrapper& operator=(MessageWrapper&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MessageWrapper& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageWrapper* internal_default_instance() {
    return reinterpret_cast<const MessageWrapper*>(
               &_MessageWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MessageWrapper* other);
  friend void swap(MessageWrapper& a, MessageWrapper& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageWrapper* New() const final {
    return CreateMaybeMessage<MessageWrapper>(nullptr);
  }

  MessageWrapper* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageWrapper>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageWrapper& from);
  void MergeFrom(const MessageWrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageWrapper* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MessageWrapper_Type Type;
  static const Type CURSOR_MOVE =
    MessageWrapper_Type_CURSOR_MOVE;
  static const Type SQUARE_FLAG =
    MessageWrapper_Type_SQUARE_FLAG;
  static const Type SQUARE_OPEN =
    MessageWrapper_Type_SQUARE_OPEN;
  static const Type PLAYER_JOIN =
    MessageWrapper_Type_PLAYER_JOIN;
  static const Type PLAYER_QUIT =
    MessageWrapper_Type_PLAYER_QUIT;
  static const Type WELCOME =
    MessageWrapper_Type_WELCOME;
  static const Type CHUNK_BYTES =
    MessageWrapper_Type_CHUNK_BYTES;
  static const Type CHUNK_REQUEST =
    MessageWrapper_Type_CHUNK_REQUEST;
  static const Type CLEAR_AT =
    MessageWrapper_Type_CLEAR_AT;
  static const Type PLAYER_UPDATE =
    MessageWrapper_Type_PLAYER_UPDATE;
  static inline bool Type_IsValid(int value) {
    return MessageWrapper_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MessageWrapper_Type_Type_MIN;
  static const Type Type_MAX =
    MessageWrapper_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MessageWrapper_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MessageWrapper_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MessageWrapper_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MessageWrapper_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .nm.message.CursorMove cursorMove = 2;
  bool has_cursormove() const;
  void clear_cursormove();
  static const int kCursorMoveFieldNumber = 2;
  const ::nm::message::CursorMove& cursormove() const;
  ::nm::message::CursorMove* release_cursormove();
  ::nm::message::CursorMove* mutable_cursormove();
  void set_allocated_cursormove(::nm::message::CursorMove* cursormove);

  // optional .nm.message.SquareOpen squareOpen = 3;
  bool has_squareopen() const;
  void clear_squareopen();
  static const int kSquareOpenFieldNumber = 3;
  const ::nm::message::SquareOpen& squareopen() const;
  ::nm::message::SquareOpen* release_squareopen();
  ::nm::message::SquareOpen* mutable_squareopen();
  void set_allocated_squareopen(::nm::message::SquareOpen* squareopen);

  // optional .nm.message.ChunkBytes chunkBytes = 4;
  bool has_chunkbytes() const;
  void clear_chunkbytes();
  static const int kChunkBytesFieldNumber = 4;
  const ::nm::message::ChunkBytes& chunkbytes() const;
  ::nm::message::ChunkBytes* release_chunkbytes();
  ::nm::message::ChunkBytes* mutable_chunkbytes();
  void set_allocated_chunkbytes(::nm::message::ChunkBytes* chunkbytes);

  // optional .nm.message.SquareFlag squareFlag = 5;
  bool has_squareflag() const;
  void clear_squareflag();
  static const int kSquareFlagFieldNumber = 5;
  const ::nm::message::SquareFlag& squareflag() const;
  ::nm::message::SquareFlag* release_squareflag();
  ::nm::message::SquareFlag* mutable_squareflag();
  void set_allocated_squareflag(::nm::message::SquareFlag* squareflag);

  // optional .nm.message.Player playerJoin = 6;
  bool has_playerjoin() const;
  void clear_playerjoin();
  static const int kPlayerJoinFieldNumber = 6;
  const ::nm::message::Player& playerjoin() const;
  ::nm::message::Player* release_playerjoin();
  ::nm::message::Player* mutable_playerjoin();
  void set_allocated_playerjoin(::nm::message::Player* playerjoin);

  // optional .nm.message.Player playerQuit = 7;
  bool has_playerquit() const;
  void clear_playerquit();
  static const int kPlayerQuitFieldNumber = 7;
  const ::nm::message::Player& playerquit() const;
  ::nm::message::Player* release_playerquit();
  ::nm::message::Player* mutable_playerquit();
  void set_allocated_playerquit(::nm::message::Player* playerquit);

  // optional .nm.message.Welcome welcome = 8;
  bool has_welcome() const;
  void clear_welcome();
  static const int kWelcomeFieldNumber = 8;
  const ::nm::message::Welcome& welcome() const;
  ::nm::message::Welcome* release_welcome();
  ::nm::message::Welcome* mutable_welcome();
  void set_allocated_welcome(::nm::message::Welcome* welcome);

  // optional .nm.message.ChunkRequest chunkRequest = 9;
  bool has_chunkrequest() const;
  void clear_chunkrequest();
  static const int kChunkRequestFieldNumber = 9;
  const ::nm::message::ChunkRequest& chunkrequest() const;
  ::nm::message::ChunkRequest* release_chunkrequest();
  ::nm::message::ChunkRequest* mutable_chunkrequest();
  void set_allocated_chunkrequest(::nm::message::ChunkRequest* chunkrequest);

  // optional .nm.message.ClearAt clearAt = 10;
  bool has_clearat() const;
  void clear_clearat();
  static const int kClearAtFieldNumber = 10;
  const ::nm::message::ClearAt& clearat() const;
  ::nm::message::ClearAt* release_clearat();
  ::nm::message::ClearAt* mutable_clearat();
  void set_allocated_clearat(::nm::message::ClearAt* clearat);

  // optional .nm.message.Player player = 11;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 11;
  const ::nm::message::Player& player() const;
  ::nm::message::Player* release_player();
  ::nm::message::Player* mutable_player();
  void set_allocated_player(::nm::message::Player* player);

  // required .nm.message.MessageWrapper.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::nm::message::MessageWrapper_Type type() const;
  void set_type(::nm::message::MessageWrapper_Type value);

  // @@protoc_insertion_point(class_scope:nm.message.MessageWrapper)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::nm::message::CursorMove* cursormove_;
  ::nm::message::SquareOpen* squareopen_;
  ::nm::message::ChunkBytes* chunkbytes_;
  ::nm::message::SquareFlag* squareflag_;
  ::nm::message::Player* playerjoin_;
  ::nm::message::Player* playerquit_;
  ::nm::message::Welcome* welcome_;
  ::nm::message::ChunkRequest* chunkrequest_;
  ::nm::message::ClearAt* clearat_;
  ::nm::message::Player* player_;
  int type_;
  friend struct ::TableStruct_netmine_2eproto;
};
// -------------------------------------------------------------------

class ClearAt final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.ClearAt) */ {
 public:
  ClearAt();
  virtual ~ClearAt();

  ClearAt(const ClearAt& from);

  inline ClearAt& operator=(const ClearAt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearAt(ClearAt&& from) noexcept
    : ClearAt() {
    *this = ::std::move(from);
  }

  inline ClearAt& operator=(ClearAt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ClearAt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearAt* internal_default_instance() {
    return reinterpret_cast<const ClearAt*>(
               &_ClearAt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ClearAt* other);
  friend void swap(ClearAt& a, ClearAt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearAt* New() const final {
    return CreateMaybeMessage<ClearAt>(nullptr);
  }

  ClearAt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearAt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClearAt& from);
  void MergeFrom(const ClearAt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearAt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nm.message.ClearAt)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend struct ::TableStruct_netmine_2eproto;
};
// -------------------------------------------------------------------

class ChunkRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.ChunkRequest) */ {
 public:
  ChunkRequest();
  virtual ~ChunkRequest();

  ChunkRequest(const ChunkRequest& from);

  inline ChunkRequest& operator=(const ChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChunkRequest(ChunkRequest&& from) noexcept
    : ChunkRequest() {
    *this = ::std::move(from);
  }

  inline ChunkRequest& operator=(ChunkRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChunkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChunkRequest* internal_default_instance() {
    return reinterpret_cast<const ChunkRequest*>(
               &_ChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ChunkRequest* other);
  friend void swap(ChunkRequest& a, ChunkRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChunkRequest* New() const final {
    return CreateMaybeMessage<ChunkRequest>(nullptr);
  }

  ChunkRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChunkRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChunkRequest& from);
  void MergeFrom(const ChunkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nm.message.ChunkRequest)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend struct ::TableStruct_netmine_2eproto;
};
// -------------------------------------------------------------------

class ChunkBytes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.ChunkBytes) */ {
 public:
  ChunkBytes();
  virtual ~ChunkBytes();

  ChunkBytes(const ChunkBytes& from);

  inline ChunkBytes& operator=(const ChunkBytes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChunkBytes(ChunkBytes&& from) noexcept
    : ChunkBytes() {
    *this = ::std::move(from);
  }

  inline ChunkBytes& operator=(ChunkBytes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChunkBytes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChunkBytes* internal_default_instance() {
    return reinterpret_cast<const ChunkBytes*>(
               &_ChunkBytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ChunkBytes* other);
  friend void swap(ChunkBytes& a, ChunkBytes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChunkBytes* New() const final {
    return CreateMaybeMessage<ChunkBytes>(nullptr);
  }

  ChunkBytes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChunkBytes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChunkBytes& from);
  void MergeFrom(const ChunkBytes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkBytes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nm.message.ChunkBytes)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend struct ::TableStruct_netmine_2eproto;
};
// -------------------------------------------------------------------

class CursorMove final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.CursorMove) */ {
 public:
  CursorMove();
  virtual ~CursorMove();

  CursorMove(const CursorMove& from);

  inline CursorMove& operator=(const CursorMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CursorMove(CursorMove&& from) noexcept
    : CursorMove() {
    *this = ::std::move(from);
  }

  inline CursorMove& operator=(CursorMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CursorMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CursorMove* internal_default_instance() {
    return reinterpret_cast<const CursorMove*>(
               &_CursorMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CursorMove* other);
  friend void swap(CursorMove& a, CursorMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CursorMove* New() const final {
    return CreateMaybeMessage<CursorMove>(nullptr);
  }

  CursorMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CursorMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CursorMove& from);
  void MergeFrom(const CursorMove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CursorMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nm.message.CursorMove)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 id_;
  friend struct ::TableStruct_netmine_2eproto;
};
// -------------------------------------------------------------------

class SquareOpen final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.SquareOpen) */ {
 public:
  SquareOpen();
  virtual ~SquareOpen();

  SquareOpen(const SquareOpen& from);

  inline SquareOpen& operator=(const SquareOpen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SquareOpen(SquareOpen&& from) noexcept
    : SquareOpen() {
    *this = ::std::move(from);
  }

  inline SquareOpen& operator=(SquareOpen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SquareOpen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SquareOpen* internal_default_instance() {
    return reinterpret_cast<const SquareOpen*>(
               &_SquareOpen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SquareOpen* other);
  friend void swap(SquareOpen& a, SquareOpen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SquareOpen* New() const final {
    return CreateMaybeMessage<SquareOpen>(nullptr);
  }

  SquareOpen* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SquareOpen>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SquareOpen& from);
  void MergeFrom(const SquareOpen& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SquareOpen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nm.message.SquareOpen)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 id_;
  friend struct ::TableStruct_netmine_2eproto;
};
// -------------------------------------------------------------------

class SquareFlag final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.SquareFlag) */ {
 public:
  SquareFlag();
  virtual ~SquareFlag();

  SquareFlag(const SquareFlag& from);

  inline SquareFlag& operator=(const SquareFlag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SquareFlag(SquareFlag&& from) noexcept
    : SquareFlag() {
    *this = ::std::move(from);
  }

  inline SquareFlag& operator=(SquareFlag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SquareFlag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SquareFlag* internal_default_instance() {
    return reinterpret_cast<const SquareFlag*>(
               &_SquareFlag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SquareFlag* other);
  friend void swap(SquareFlag& a, SquareFlag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SquareFlag* New() const final {
    return CreateMaybeMessage<SquareFlag>(nullptr);
  }

  SquareFlag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SquareFlag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SquareFlag& from);
  void MergeFrom(const SquareFlag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SquareFlag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nm.message.SquareFlag)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 id_;
  friend struct ::TableStruct_netmine_2eproto;
};
// -------------------------------------------------------------------

class Player final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Player* other);
  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(nullptr);
  }

  Player* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nm.message.Player)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 id_;
  friend struct ::TableStruct_netmine_2eproto;
};
// -------------------------------------------------------------------

class Welcome final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nm.message.Welcome) */ {
 public:
  Welcome();
  virtual ~Welcome();

  Welcome(const Welcome& from);

  inline Welcome& operator=(const Welcome& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Welcome(Welcome&& from) noexcept
    : Welcome() {
    *this = ::std::move(from);
  }

  inline Welcome& operator=(Welcome&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Welcome& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Welcome* internal_default_instance() {
    return reinterpret_cast<const Welcome*>(
               &_Welcome_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Welcome* other);
  friend void swap(Welcome& a, Welcome& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Welcome* New() const final {
    return CreateMaybeMessage<Welcome>(nullptr);
  }

  Welcome* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Welcome>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Welcome& from);
  void MergeFrom(const Welcome& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Welcome* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nm.message.Player players = 3;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 3;
  ::nm::message::Player* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::nm::message::Player >*
      mutable_players();
  const ::nm::message::Player& players(int index) const;
  ::nm::message::Player* add_players();
  const ::google::protobuf::RepeatedPtrField< ::nm::message::Player >&
      players() const;

  // required int32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // required int32 nPlayers = 2;
  bool has_nplayers() const;
  void clear_nplayers();
  static const int kNPlayersFieldNumber = 2;
  ::google::protobuf::int32 nplayers() const;
  void set_nplayers(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nm.message.Welcome)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::nm::message::Player > players_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 nplayers_;
  friend struct ::TableStruct_netmine_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MessageWrapper

// required .nm.message.MessageWrapper.Type type = 1;
inline bool MessageWrapper::has_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MessageWrapper::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::nm::message::MessageWrapper_Type MessageWrapper::type() const {
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.type)
  return static_cast< ::nm::message::MessageWrapper_Type >(type_);
}
inline void MessageWrapper::set_type(::nm::message::MessageWrapper_Type value) {
  assert(::nm::message::MessageWrapper_Type_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  type_ = value;
  // @@protoc_insertion_point(field_set:nm.message.MessageWrapper.type)
}

// optional .nm.message.CursorMove cursorMove = 2;
inline bool MessageWrapper::has_cursormove() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageWrapper::clear_cursormove() {
  if (cursormove_ != nullptr) cursormove_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::nm::message::CursorMove& MessageWrapper::cursormove() const {
  const ::nm::message::CursorMove* p = cursormove_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.cursorMove)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::CursorMove*>(
      &::nm::message::_CursorMove_default_instance_);
}
inline ::nm::message::CursorMove* MessageWrapper::release_cursormove() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.cursorMove)
  _has_bits_[0] &= ~0x00000001u;
  ::nm::message::CursorMove* temp = cursormove_;
  cursormove_ = nullptr;
  return temp;
}
inline ::nm::message::CursorMove* MessageWrapper::mutable_cursormove() {
  _has_bits_[0] |= 0x00000001u;
  if (cursormove_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::CursorMove>(GetArenaNoVirtual());
    cursormove_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.cursorMove)
  return cursormove_;
}
inline void MessageWrapper::set_allocated_cursormove(::nm::message::CursorMove* cursormove) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cursormove_;
  }
  if (cursormove) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cursormove = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cursormove, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cursormove_ = cursormove;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.cursorMove)
}

// optional .nm.message.SquareOpen squareOpen = 3;
inline bool MessageWrapper::has_squareopen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageWrapper::clear_squareopen() {
  if (squareopen_ != nullptr) squareopen_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::nm::message::SquareOpen& MessageWrapper::squareopen() const {
  const ::nm::message::SquareOpen* p = squareopen_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.squareOpen)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::SquareOpen*>(
      &::nm::message::_SquareOpen_default_instance_);
}
inline ::nm::message::SquareOpen* MessageWrapper::release_squareopen() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.squareOpen)
  _has_bits_[0] &= ~0x00000002u;
  ::nm::message::SquareOpen* temp = squareopen_;
  squareopen_ = nullptr;
  return temp;
}
inline ::nm::message::SquareOpen* MessageWrapper::mutable_squareopen() {
  _has_bits_[0] |= 0x00000002u;
  if (squareopen_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::SquareOpen>(GetArenaNoVirtual());
    squareopen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.squareOpen)
  return squareopen_;
}
inline void MessageWrapper::set_allocated_squareopen(::nm::message::SquareOpen* squareopen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete squareopen_;
  }
  if (squareopen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      squareopen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, squareopen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  squareopen_ = squareopen;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.squareOpen)
}

// optional .nm.message.ChunkBytes chunkBytes = 4;
inline bool MessageWrapper::has_chunkbytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageWrapper::clear_chunkbytes() {
  if (chunkbytes_ != nullptr) chunkbytes_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::nm::message::ChunkBytes& MessageWrapper::chunkbytes() const {
  const ::nm::message::ChunkBytes* p = chunkbytes_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.chunkBytes)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::ChunkBytes*>(
      &::nm::message::_ChunkBytes_default_instance_);
}
inline ::nm::message::ChunkBytes* MessageWrapper::release_chunkbytes() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.chunkBytes)
  _has_bits_[0] &= ~0x00000004u;
  ::nm::message::ChunkBytes* temp = chunkbytes_;
  chunkbytes_ = nullptr;
  return temp;
}
inline ::nm::message::ChunkBytes* MessageWrapper::mutable_chunkbytes() {
  _has_bits_[0] |= 0x00000004u;
  if (chunkbytes_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::ChunkBytes>(GetArenaNoVirtual());
    chunkbytes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.chunkBytes)
  return chunkbytes_;
}
inline void MessageWrapper::set_allocated_chunkbytes(::nm::message::ChunkBytes* chunkbytes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chunkbytes_;
  }
  if (chunkbytes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chunkbytes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chunkbytes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  chunkbytes_ = chunkbytes;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.chunkBytes)
}

// optional .nm.message.SquareFlag squareFlag = 5;
inline bool MessageWrapper::has_squareflag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageWrapper::clear_squareflag() {
  if (squareflag_ != nullptr) squareflag_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::nm::message::SquareFlag& MessageWrapper::squareflag() const {
  const ::nm::message::SquareFlag* p = squareflag_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.squareFlag)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::SquareFlag*>(
      &::nm::message::_SquareFlag_default_instance_);
}
inline ::nm::message::SquareFlag* MessageWrapper::release_squareflag() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.squareFlag)
  _has_bits_[0] &= ~0x00000008u;
  ::nm::message::SquareFlag* temp = squareflag_;
  squareflag_ = nullptr;
  return temp;
}
inline ::nm::message::SquareFlag* MessageWrapper::mutable_squareflag() {
  _has_bits_[0] |= 0x00000008u;
  if (squareflag_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::SquareFlag>(GetArenaNoVirtual());
    squareflag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.squareFlag)
  return squareflag_;
}
inline void MessageWrapper::set_allocated_squareflag(::nm::message::SquareFlag* squareflag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete squareflag_;
  }
  if (squareflag) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      squareflag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, squareflag, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  squareflag_ = squareflag;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.squareFlag)
}

// optional .nm.message.Player playerJoin = 6;
inline bool MessageWrapper::has_playerjoin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageWrapper::clear_playerjoin() {
  if (playerjoin_ != nullptr) playerjoin_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::nm::message::Player& MessageWrapper::playerjoin() const {
  const ::nm::message::Player* p = playerjoin_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.playerJoin)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::Player*>(
      &::nm::message::_Player_default_instance_);
}
inline ::nm::message::Player* MessageWrapper::release_playerjoin() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.playerJoin)
  _has_bits_[0] &= ~0x00000010u;
  ::nm::message::Player* temp = playerjoin_;
  playerjoin_ = nullptr;
  return temp;
}
inline ::nm::message::Player* MessageWrapper::mutable_playerjoin() {
  _has_bits_[0] |= 0x00000010u;
  if (playerjoin_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::Player>(GetArenaNoVirtual());
    playerjoin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.playerJoin)
  return playerjoin_;
}
inline void MessageWrapper::set_allocated_playerjoin(::nm::message::Player* playerjoin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playerjoin_;
  }
  if (playerjoin) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playerjoin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerjoin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  playerjoin_ = playerjoin;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.playerJoin)
}

// optional .nm.message.Player playerQuit = 7;
inline bool MessageWrapper::has_playerquit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageWrapper::clear_playerquit() {
  if (playerquit_ != nullptr) playerquit_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::nm::message::Player& MessageWrapper::playerquit() const {
  const ::nm::message::Player* p = playerquit_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.playerQuit)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::Player*>(
      &::nm::message::_Player_default_instance_);
}
inline ::nm::message::Player* MessageWrapper::release_playerquit() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.playerQuit)
  _has_bits_[0] &= ~0x00000020u;
  ::nm::message::Player* temp = playerquit_;
  playerquit_ = nullptr;
  return temp;
}
inline ::nm::message::Player* MessageWrapper::mutable_playerquit() {
  _has_bits_[0] |= 0x00000020u;
  if (playerquit_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::Player>(GetArenaNoVirtual());
    playerquit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.playerQuit)
  return playerquit_;
}
inline void MessageWrapper::set_allocated_playerquit(::nm::message::Player* playerquit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playerquit_;
  }
  if (playerquit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playerquit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerquit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  playerquit_ = playerquit;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.playerQuit)
}

// optional .nm.message.Welcome welcome = 8;
inline bool MessageWrapper::has_welcome() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageWrapper::clear_welcome() {
  if (welcome_ != nullptr) welcome_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::nm::message::Welcome& MessageWrapper::welcome() const {
  const ::nm::message::Welcome* p = welcome_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.welcome)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::Welcome*>(
      &::nm::message::_Welcome_default_instance_);
}
inline ::nm::message::Welcome* MessageWrapper::release_welcome() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.welcome)
  _has_bits_[0] &= ~0x00000040u;
  ::nm::message::Welcome* temp = welcome_;
  welcome_ = nullptr;
  return temp;
}
inline ::nm::message::Welcome* MessageWrapper::mutable_welcome() {
  _has_bits_[0] |= 0x00000040u;
  if (welcome_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::Welcome>(GetArenaNoVirtual());
    welcome_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.welcome)
  return welcome_;
}
inline void MessageWrapper::set_allocated_welcome(::nm::message::Welcome* welcome) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete welcome_;
  }
  if (welcome) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      welcome = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, welcome, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  welcome_ = welcome;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.welcome)
}

// optional .nm.message.ChunkRequest chunkRequest = 9;
inline bool MessageWrapper::has_chunkrequest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessageWrapper::clear_chunkrequest() {
  if (chunkrequest_ != nullptr) chunkrequest_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::nm::message::ChunkRequest& MessageWrapper::chunkrequest() const {
  const ::nm::message::ChunkRequest* p = chunkrequest_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.chunkRequest)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::ChunkRequest*>(
      &::nm::message::_ChunkRequest_default_instance_);
}
inline ::nm::message::ChunkRequest* MessageWrapper::release_chunkrequest() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.chunkRequest)
  _has_bits_[0] &= ~0x00000080u;
  ::nm::message::ChunkRequest* temp = chunkrequest_;
  chunkrequest_ = nullptr;
  return temp;
}
inline ::nm::message::ChunkRequest* MessageWrapper::mutable_chunkrequest() {
  _has_bits_[0] |= 0x00000080u;
  if (chunkrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::ChunkRequest>(GetArenaNoVirtual());
    chunkrequest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.chunkRequest)
  return chunkrequest_;
}
inline void MessageWrapper::set_allocated_chunkrequest(::nm::message::ChunkRequest* chunkrequest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chunkrequest_;
  }
  if (chunkrequest) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chunkrequest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chunkrequest, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  chunkrequest_ = chunkrequest;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.chunkRequest)
}

// optional .nm.message.ClearAt clearAt = 10;
inline bool MessageWrapper::has_clearat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MessageWrapper::clear_clearat() {
  if (clearat_ != nullptr) clearat_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::nm::message::ClearAt& MessageWrapper::clearat() const {
  const ::nm::message::ClearAt* p = clearat_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.clearAt)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::ClearAt*>(
      &::nm::message::_ClearAt_default_instance_);
}
inline ::nm::message::ClearAt* MessageWrapper::release_clearat() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.clearAt)
  _has_bits_[0] &= ~0x00000100u;
  ::nm::message::ClearAt* temp = clearat_;
  clearat_ = nullptr;
  return temp;
}
inline ::nm::message::ClearAt* MessageWrapper::mutable_clearat() {
  _has_bits_[0] |= 0x00000100u;
  if (clearat_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::ClearAt>(GetArenaNoVirtual());
    clearat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.clearAt)
  return clearat_;
}
inline void MessageWrapper::set_allocated_clearat(::nm::message::ClearAt* clearat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete clearat_;
  }
  if (clearat) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      clearat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, clearat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  clearat_ = clearat;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.clearAt)
}

// optional .nm.message.Player player = 11;
inline bool MessageWrapper::has_player() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MessageWrapper::clear_player() {
  if (player_ != nullptr) player_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::nm::message::Player& MessageWrapper::player() const {
  const ::nm::message::Player* p = player_;
  // @@protoc_insertion_point(field_get:nm.message.MessageWrapper.player)
  return p != nullptr ? *p : *reinterpret_cast<const ::nm::message::Player*>(
      &::nm::message::_Player_default_instance_);
}
inline ::nm::message::Player* MessageWrapper::release_player() {
  // @@protoc_insertion_point(field_release:nm.message.MessageWrapper.player)
  _has_bits_[0] &= ~0x00000200u;
  ::nm::message::Player* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::nm::message::Player* MessageWrapper::mutable_player() {
  _has_bits_[0] |= 0x00000200u;
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::nm::message::Player>(GetArenaNoVirtual());
    player_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nm.message.MessageWrapper.player)
  return player_;
}
inline void MessageWrapper::set_allocated_player(::nm::message::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:nm.message.MessageWrapper.player)
}

// -------------------------------------------------------------------

// ClearAt

// required int32 x = 1;
inline bool ClearAt::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClearAt::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 ClearAt::x() const {
  // @@protoc_insertion_point(field_get:nm.message.ClearAt.x)
  return x_;
}
inline void ClearAt::set_x(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:nm.message.ClearAt.x)
}

// required int32 y = 2;
inline bool ClearAt::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClearAt::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 ClearAt::y() const {
  // @@protoc_insertion_point(field_get:nm.message.ClearAt.y)
  return y_;
}
inline void ClearAt::set_y(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:nm.message.ClearAt.y)
}

// -------------------------------------------------------------------

// ChunkRequest

// required int32 x = 1;
inline bool ChunkRequest::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChunkRequest::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 ChunkRequest::x() const {
  // @@protoc_insertion_point(field_get:nm.message.ChunkRequest.x)
  return x_;
}
inline void ChunkRequest::set_x(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:nm.message.ChunkRequest.x)
}

// required int32 y = 2;
inline bool ChunkRequest::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChunkRequest::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 ChunkRequest::y() const {
  // @@protoc_insertion_point(field_get:nm.message.ChunkRequest.y)
  return y_;
}
inline void ChunkRequest::set_y(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:nm.message.ChunkRequest.y)
}

// -------------------------------------------------------------------

// ChunkBytes

// required int32 x = 1;
inline bool ChunkBytes::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChunkBytes::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 ChunkBytes::x() const {
  // @@protoc_insertion_point(field_get:nm.message.ChunkBytes.x)
  return x_;
}
inline void ChunkBytes::set_x(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  x_ = value;
  // @@protoc_insertion_point(field_set:nm.message.ChunkBytes.x)
}

// required int32 y = 2;
inline bool ChunkBytes::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChunkBytes::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 ChunkBytes::y() const {
  // @@protoc_insertion_point(field_get:nm.message.ChunkBytes.y)
  return y_;
}
inline void ChunkBytes::set_y(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  y_ = value;
  // @@protoc_insertion_point(field_set:nm.message.ChunkBytes.y)
}

// required bytes data = 3;
inline bool ChunkBytes::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChunkBytes::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ChunkBytes::data() const {
  // @@protoc_insertion_point(field_get:nm.message.ChunkBytes.data)
  return data_.GetNoArena();
}
inline void ChunkBytes::set_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nm.message.ChunkBytes.data)
}
#if LANG_CXX11
inline void ChunkBytes::set_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nm.message.ChunkBytes.data)
}
#endif
inline void ChunkBytes::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nm.message.ChunkBytes.data)
}
inline void ChunkBytes::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nm.message.ChunkBytes.data)
}
inline ::std::string* ChunkBytes::mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:nm.message.ChunkBytes.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChunkBytes::release_data() {
  // @@protoc_insertion_point(field_release:nm.message.ChunkBytes.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChunkBytes::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:nm.message.ChunkBytes.data)
}

// -------------------------------------------------------------------

// CursorMove

// required int32 x = 1;
inline bool CursorMove::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CursorMove::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 CursorMove::x() const {
  // @@protoc_insertion_point(field_get:nm.message.CursorMove.x)
  return x_;
}
inline void CursorMove::set_x(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:nm.message.CursorMove.x)
}

// required int32 y = 2;
inline bool CursorMove::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CursorMove::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 CursorMove::y() const {
  // @@protoc_insertion_point(field_get:nm.message.CursorMove.y)
  return y_;
}
inline void CursorMove::set_y(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:nm.message.CursorMove.y)
}

// optional int32 id = 3;
inline bool CursorMove::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CursorMove::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 CursorMove::id() const {
  // @@protoc_insertion_point(field_get:nm.message.CursorMove.id)
  return id_;
}
inline void CursorMove::set_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
  // @@protoc_insertion_point(field_set:nm.message.CursorMove.id)
}

// -------------------------------------------------------------------

// SquareOpen

// required int32 x = 1;
inline bool SquareOpen::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SquareOpen::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 SquareOpen::x() const {
  // @@protoc_insertion_point(field_get:nm.message.SquareOpen.x)
  return x_;
}
inline void SquareOpen::set_x(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:nm.message.SquareOpen.x)
}

// required int32 y = 2;
inline bool SquareOpen::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SquareOpen::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 SquareOpen::y() const {
  // @@protoc_insertion_point(field_get:nm.message.SquareOpen.y)
  return y_;
}
inline void SquareOpen::set_y(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:nm.message.SquareOpen.y)
}

// optional int32 id = 3;
inline bool SquareOpen::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SquareOpen::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 SquareOpen::id() const {
  // @@protoc_insertion_point(field_get:nm.message.SquareOpen.id)
  return id_;
}
inline void SquareOpen::set_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
  // @@protoc_insertion_point(field_set:nm.message.SquareOpen.id)
}

// -------------------------------------------------------------------

// SquareFlag

// required int32 x = 1;
inline bool SquareFlag::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SquareFlag::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 SquareFlag::x() const {
  // @@protoc_insertion_point(field_get:nm.message.SquareFlag.x)
  return x_;
}
inline void SquareFlag::set_x(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:nm.message.SquareFlag.x)
}

// required int32 y = 2;
inline bool SquareFlag::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SquareFlag::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 SquareFlag::y() const {
  // @@protoc_insertion_point(field_get:nm.message.SquareFlag.y)
  return y_;
}
inline void SquareFlag::set_y(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:nm.message.SquareFlag.y)
}

// optional int32 id = 3;
inline bool SquareFlag::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SquareFlag::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 SquareFlag::id() const {
  // @@protoc_insertion_point(field_get:nm.message.SquareFlag.id)
  return id_;
}
inline void SquareFlag::set_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
  // @@protoc_insertion_point(field_set:nm.message.SquareFlag.id)
}

// -------------------------------------------------------------------

// Player

// required int32 x = 1;
inline bool Player::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Player::x() const {
  // @@protoc_insertion_point(field_get:nm.message.Player.x)
  return x_;
}
inline void Player::set_x(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  x_ = value;
  // @@protoc_insertion_point(field_set:nm.message.Player.x)
}

// required int32 y = 2;
inline bool Player::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 Player::y() const {
  // @@protoc_insertion_point(field_get:nm.message.Player.y)
  return y_;
}
inline void Player::set_y(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  y_ = value;
  // @@protoc_insertion_point(field_set:nm.message.Player.y)
}

// optional int32 id = 3;
inline bool Player::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 Player::id() const {
  // @@protoc_insertion_point(field_get:nm.message.Player.id)
  return id_;
}
inline void Player::set_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  id_ = value;
  // @@protoc_insertion_point(field_set:nm.message.Player.id)
}

// optional string name = 4;
inline bool Player::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:nm.message.Player.name)
  return name_.GetNoArena();
}
inline void Player::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nm.message.Player.name)
}
#if LANG_CXX11
inline void Player::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nm.message.Player.name)
}
#endif
inline void Player::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nm.message.Player.name)
}
inline void Player::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nm.message.Player.name)
}
inline ::std::string* Player::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:nm.message.Player.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:nm.message.Player.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nm.message.Player.name)
}

// -------------------------------------------------------------------

// Welcome

// required int32 version = 1;
inline bool Welcome::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Welcome::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 Welcome::version() const {
  // @@protoc_insertion_point(field_get:nm.message.Welcome.version)
  return version_;
}
inline void Welcome::set_version(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  version_ = value;
  // @@protoc_insertion_point(field_set:nm.message.Welcome.version)
}

// required int32 nPlayers = 2;
inline bool Welcome::has_nplayers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Welcome::clear_nplayers() {
  nplayers_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Welcome::nplayers() const {
  // @@protoc_insertion_point(field_get:nm.message.Welcome.nPlayers)
  return nplayers_;
}
inline void Welcome::set_nplayers(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  nplayers_ = value;
  // @@protoc_insertion_point(field_set:nm.message.Welcome.nPlayers)
}

// repeated .nm.message.Player players = 3;
inline int Welcome::players_size() const {
  return players_.size();
}
inline void Welcome::clear_players() {
  players_.Clear();
}
inline ::nm::message::Player* Welcome::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:nm.message.Welcome.players)
  return players_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nm::message::Player >*
Welcome::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:nm.message.Welcome.players)
  return &players_;
}
inline const ::nm::message::Player& Welcome::players(int index) const {
  // @@protoc_insertion_point(field_get:nm.message.Welcome.players)
  return players_.Get(index);
}
inline ::nm::message::Player* Welcome::add_players() {
  // @@protoc_insertion_point(field_add:nm.message.Welcome.players)
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nm::message::Player >&
Welcome::players() const {
  // @@protoc_insertion_point(field_list:nm.message.Welcome.players)
  return players_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message
}  // namespace nm

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nm::message::MessageWrapper_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nm::message::MessageWrapper_Type>() {
  return ::nm::message::MessageWrapper_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_netmine_2eproto
